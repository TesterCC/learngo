# Go断点续传示例

这个项目演示了使用Go语言实现的简单断点续传功能。
目前只实现了下载的功能；

Todo：支持client上传的断点续传和分片下载

## 项目结构

- `server/`: 服务端代码，`server/files/` 下存储可下载文件 
- `client/`: 客户端代码
- `util/`: 工具代码，包含共享的数据结构

## 使用方法

### 1. 启动服务端

```bash
cd server
go run server.go
```

服务器将在 http://localhost:1234 上启动。

### 2. 运行客户端

```bash
cd client
go run client.go
```

客户端将尝试下载名为"test.mp4"的文件。如果下载中断，再次运行客户端将从断点处继续下载。

## 实现原理

### 断点续传核心机制

1. **断点位置记录**：客户端通过检查本地文件大小确定已下载的字节数（断点位置）
   - 使用`os.OpenFile`以追加模式（`os.O_APPEND`）打开文件，确保新数据添加到文件末尾
   - 通过`fout.Stat()`获取文件当前大小，作为断点位置

2. **断点信息传递**：客户端在请求中包含文件名和断点位置信息
   - 使用`util.GetRequest`结构体封装请求参数
   - 将请求参数序列化为JSON格式发送给服务端

3. **服务端断点处理**：服务端从指定位置开始传输文件
   - 解析客户端请求中的断点位置（`StartPoint`）
   - 使用`fin.Seek(int64(request.StartPoint), 0)`将文件指针移动到断点位置
   - 从断点位置开始读取文件内容并发送给客户端

4. **文件大小传递**：服务端通过HTTP响应头告知客户端文件总大小
   - 使用`w.Header().Add("File-Size", strconv.FormatInt(FileSize, 10))`设置响应头
   - 客户端从响应头中解析文件总大小，用于计算下载进度

5. **数据追加存储**：客户端将接收到的数据追加到本地文件末尾
   - 使用缓冲区（1KB）分块读取响应体数据
   - 将读取到的数据写入本地文件，实现断点续传

### 进度显示实现

1. **进度条结构**：使用`util.Bar`结构体实现命令行进度条
   - 记录当前位置、总大小、百分比、开始时间等信息
   - 使用Unicode方块字符（`█`）构建可视化进度条

2. **速度计算**：通过已下载字节数与经过时间的比值计算下载速度
   - 使用`time.Since(bar.start).Seconds()`计算经过的时间
   - 计算公式：下载速度(KB/s) = 已下载字节数 / 经过时间 / 1024

3. **实时更新**：每读取一块数据后更新并显示进度条
   - 进度条格式：`[████████████████████████        ]48% 1254.67 KB/s`
   - 使用`\r`实现同一行更新，避免刷屏

### 技术亮点

1. **简单高效**：无需复杂的协议和状态管理，通过HTTP和文件系统实现断点续传
2. **通用性强**：适用于各种文件类型，不限制文件大小
3. **用户友好**：提供直观的进度显示，帮助用户了解下载状态
4. **容错能力**：网络中断或程序崩溃后，可从断点处恢复下载，节省时间和带宽

这种实现方式简单而有效，适合在网络不稳定的环境中传输大文件，避免因网络中断导致的重复下载。